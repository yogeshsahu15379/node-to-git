default:
  image: node:14

cache: &global_cache
  policy: pull
  paths:
    - .npm/
    - node_modules/

stages:
  - test
  - build
  - post-build
  - pre-deploy
  - deploy
  - release

variables:
  NPM_TOKEN: ${CI_JOB_TOKEN}
  STORYBOOK_IMAGE: ${CI_REGISTRY_IMAGE}/storybook

install:
  stage: .pre
  script:
    - npm install
    - npm ci --cache .npm --prefer-offline
  cache:
    # inherit all global cache settings
    <<: *global_cache
    # override the policy
    policy: push
  except:
    refs:
      - schedules

eslint-prettier:
  stage: test
  script:
    - npm install
    - npm run lint
  except:
    refs:
      - schedules

spec:
  stage: test
  script:
    - echo "Run spec"
  except:
    refs:
      - schedules

e2e:
  stage: test
  script:
    - echo "Run e2e"
  except:
    refs:
      - schedules

build-stencil:
  stage: build
  script:
    - npm install
    - npm install @types/responselike@1.0.0 --save-dev
    - npm run build
  artifacts:
    paths:
      - dist/
      - loader/
      - www/
  except:
    refs:
      - schedules

build-storybook:
  stage: post-build
  script:
    - npm install
    - npm install @types/responselike@1.0.0 --save-dev
    - npm run storybook.prod.build
  artifacts:
    paths:
      - storybook-static/
  except:
    refs:
      - schedules

build-docker:
  stage: pre-deploy
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: ['']
  script:
    # Deploy built storybook to a Docker container.
    # @see .gitlab-ci/Dockerfile
    - .gitlab-ci/bin/push_image.sh
  needs: ['build-storybook']

pages:
  stage: deploy
  script:
    - cp -r storybook-static public
  artifacts:
    paths:
      - public
  only:
    - dev
    - master
    - /^issue/
  except:
    refs:
      - schedules
  needs: ['build-storybook']

deploy-storybook:
  stage: deploy
  image:
    # @todo Find a slimmer image to run these commands in.
    name: outrigger/cli
  environment: &environment
    # Cannot use environment variables here, only gitlab variables.
    # Also cannot use $PROJECT_ENV since GitLab doesn't support vars in vars.
    name: ${CI_COMMIT_REF_SLUG}
    # A human URL is added by the deployment. This is just for GitLab use.
    url: http://design-${CI_COMMIT_SHORT_SHA}-${PROJECT_NAME}.kube.fayze2.com
    on_stop: remove-storybook
  script:
    - .gitlab-ci/bin/deploy.sh
  cache: &manifest_cache
    key: ${PROJECT_NAME}-manifest-${CI_COMMIT_REF_SLUG}
    policy: push
    paths:
      - .manifests
      # Cache scripts for use in later stop action.
      - .env
      - .gitlab-ci
      - bin
  # Upload manifest artifact if deploy fails.
  artifacts:
    paths:
      - .manifests
    when: on_failure
  only:
    - dev
    - master
    - /^issue/

remove-storybook:
  stage: deploy
  image:
    # @todo Find a slimmer image to run these commands in.
    name: outrigger/cli
  variables:
    # Branch might have been deleted, so don't try to pull it.
    GIT_STRATEGY: none
  environment:
    <<: *environment
    action: stop
  script:
    # Repo branch could have been deleted, so can't checkout any code.
    # but scripts are cached in manifest_cache.
    # Ensure external script errors don't abort the script.
    - set +e
    # Ensure RELEASE_NAME is set correctly.
    - source .gitlab-ci/bin/release_name.sh
    # Hard-code the script to delete environment based on manifest cache.
    - namespace=$([ ${KUBE_NAMESPACE} ] && echo "-n ${KUBE_NAMESPACE}" || echo "-n ${PROJECT_NAME}")
    - kubectl delete ${namespace} --recursive --filename .manifests
  cache:
    <<: *manifest_cache
    policy: pull
  only:
    - dev
    - master
    - /^issue/
  when: manual

# We need to make this run last because semantic release changes the git hash.
package:
  stage: release
  before_script:
  ##
  ## Install ssh-agent if not already installed, it is required by Docker.
  ## (change apt-get to yum if you use an RPM-based image)
  ##
  - 'command -v ssh-agent >/dev/null || ( apt-get update -y && apt-get install openssh-client -y )'

  ##
  ## Run ssh-agent (inside the build environment)
  ##
  - eval $(ssh-agent -s)

  ##
  ## Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store
  ## We're using tr to fix line endings which makes ed25519 keys work
  ## without extra base64 encoding.
  ## https://gitlab.com/gitlab-examples/ssh-private-key/issues/1#note_48526556
  ##
  - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -

  ##
  ## Create the SSH directory and give it the right permissions
  ##
  - mkdir -p ~/.ssh
  - chmod 700 ~/.ssh
  - echo "$SSH_KNOWN_HOSTS" >> ~/.ssh/known_hosts
  - chmod 700 ~/.ssh/known_hosts
  - npm install @semantic-release/gitlab
  script:
    - npm install
    - npm install @types/responselike@1.0.0 --save-dev
    - |
      {
        echo "@${CI_PROJECT_ROOT_NAMESPACE}:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/"
        echo "${CI_API_V4_URL#https?}/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=\${CI_JOB_TOKEN}"
      } | tee --append .npmrc
    - npm run semantic-release
  only:
    - dev
    - master
  except:
    refs:
      - schedules

renovate:
  stage: build
  image:
    name: renovate/renovate
    entrypoint: ['']
  script:
    - >
      renovate
      --token "${RENOVATE_TOKEN}"
      --platform "gitlab"
      --endpoint "${CI_API_V4_URL}"
      --dry-run "${RENOVATE_DRY_RUN}"
      "${CI_PROJECT_PATH}"
  only:
    refs:
      - schedules
    variables:
      - $WHICH_SCHEDULE == "renovate"
